# 🧠 알고리즘 - 그리디 알고리즘: 거스름돈 문제

**거스름돈 문제**는 **그리디 알고리즘(Greedy Algorithm)** 의 대표적인 기초 문제입니다.  
항상 **현재 상황에서 가장 큰 동전부터 선택**해, 전체적으로도 최적해(최소 개수의 동전)로 이어지는 문제입니다.

---

## 1️⃣ 문제 설명

| 항목 | 내용 |
|------|------|
| **문제** | 손님에게 거스름돈을 줄 때, **동전의 개수를 최소화**해서 주는 방법 |
| **조건** | 사용할 수 있는 동전 종류가 정해져 있고, 충분히 있다고 가정 |
| **전제** | 항상 큰 단위의 동전이 작은 단위의 배수일 때만 그리디가 최적 보장 |

---

## 2️⃣ 그리디 알고리즘 접근법

1. **큰 단위의 동전부터 차례대로 선택**  
2. 가능한 만큼 최대한 그 동전 사용  
3. 남은 금액을 더 작은 동전으로 반복

> → 매 선택에서 **지역 최적(Local Optimal)** 을 따르지만,  
> 조건이 맞는다면 결국 **전역 최적(Global Optimal)** 으로 이어짐

---

## 3️⃣ 예제 (단위: 500, 100, 50, 10원)

```text
예: 1260원을 거슬러줄 때

1. 500원: 2개 → 1000원  
2. 100원: 2개 →  200원  
3.  50원: 1개 →   50원  
4.  10원: 1개 →   10원  
총: 6개
```

---

## 4️⃣ 파이썬 코드 예시

```python
def get_change(money):
    coins = [500, 100, 50, 10]
    count = 0

    for coin in coins:
        count += money // coin
        money %= coin
    
    return count

print(get_change(1260))  # 출력: 6
```

---

## 5️⃣ 그리디 알고리즘의 전제 조건

| 조건                    | 설명 |
|-------------------------|------|
| ✅ **동전 단위가 배수 관계일 것** | 예: 500, 100, 50, 10 → OK |
| ❌ **임의의 단위일 경우 최적 보장 안 됨** | 예: 400, 300, 100 → 그리디로는 실패 가능성 |

---

## 6️⃣ 그리디 알고리즘 실패 예시 (반례)

### 문제 조건

- 사용할 수 있는 동전 단위: `500`, `400`, `100`  
- 거슬러 줘야 할 금액: `800`

---

### 그리디 알고리즘 풀이

1. 가장 큰 동전인 `500원`부터 최대한 사용  
2. `800 // 500 = 1` → 500원 1개 사용  
3. 남은 금액: `800 - 500 = 300`  
4. **남은 300원을 만들 수 있는 동전 없음** ❌  
   - 400 ❌ (300보다 큼)  
   - 100 ❌ (300이지만 이미 500 써서 안 맞음)

> 💥 **결과: 실패 (거스름돈을 만들 수 없음)**

---

### 동적 계획법(DP) 풀이 (최적해)

> **조합 탐색**을 통해 금액을 정확히 만들 수 있는 방법을 찾음

- `400 + 400 = 800` → 동전 2개  
- `400 + 100 + 100 + 100 = 800` → 동전 4개  
- `100 × 8 = 800` → 동전 8개  
- ...

> 👉 최소 개수는: `400 × 2 = 2개` ✅


---

## 🎯 정리 요약

✔ **그리디 알고리즘**은 매 순간 최적 선택을 해나가는 방식  
✔ 거스름돈 문제는 **동전 단위가 배수일 경우** 최적 결과 보장  
✔ 동전 단위가 다양할 경우 → **DP나 완전탐색**으로 전환 필요

