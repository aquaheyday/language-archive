# 🧠 Algorithms - 너비 우선 탐색 (Breadth-First Search, BFS)

**너비 우선 탐색(BFS)** 은 **가까운 노드부터 먼저 탐색**하는 방식의 그래프 탐색 알고리즘입니다.  
**큐(Queue)** 를 활용하여, 현재 노드와 연결된 인접 노드들을 먼저 방문합니다.

> 보통 **최단 경로 문제**나 **레벨 순서 탐색** 등에 자주 사용됨  

---

## 1️⃣ 핵심 아이디어

1. 그래프에서 **시작 노드부터 가까운 노드**를 차례로 방문
2. **큐(Queue)** 를 이용해 방문 순서 유지
3. 각 노드는 **한 번만 방문**하도록 `visited` 처리
4. **재귀보다 반복문**으로 구현되는 경우가 일반적

---

## 2️⃣ JavaScript 구현 예시 (반복형)

```js
function bfs(graph, start) {
  const visited = new Set();
  const queue = [start];
  visited.add(start);

  while (queue.length > 0) {
    const node = queue.shift();
    console.log(node); // 또는 결과 배열에 push

    for (const neighbor of graph[node]) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push(neighbor);
      }
    }
  }
}
```

---

## 3️⃣ 예시

#### 그래프 형태:
```
    A
   / \
  B   C
 / \   \
D   E   F
```

#### BFS 탐색 순서 (시작: A):
1. A → 시작 노드
2. B, C → A에서 1단계 (가까운 노드들)
3. D, E, F → A에서 2단계 (그 다음 가까운 노드들)

#### 결과: `A → B → C → D → E → F`

---

## 4️⃣ 시간/공간 복잡도

| 항목             | 복잡도       |
|------------------|--------------|
| 시간 복잡도       | O(V + E)     |
| 공간 복잡도       | O(V)         |

> V: 노드 수, E: 간선 수  
> 방문 처리를 하지 않으면 무한 루프가 발생할 수 있음

---

## 5️⃣ 장점 vs 단점

| 장점                                 | 단점                           |
|--------------------------------------|--------------------------------|
| 최단 거리 탐색에 유리 (가중치 동일한 경우) | 큐와 visited 등 추가 메모리 필요 |
| 구현이 간단하고 직관적                | 깊은 탐색에는 비효율적          |
| 레벨 탐색(트리, 그래프 등)에 유리      | 노드 수 많으면 메모리 많이 사용 |

---

## 🎯 정리

✔ BFS는 **가까운 노드부터 차례로 탐색**하는 그래프 탐색 알고리즘  
✔ **큐와 방문 처리**를 통해 효율적인 순회 가능  
✔ **최단 거리 문제**와 **레벨 순회** 등에 매우 유용  
✔ 시간복잡도는 **O(V + E)** 로, 노드와 간선 수에 비례

