# 🧠 알고리즘 - 그리디: 회의실 배정 문제

**회의실 배정 문제**는 일정이 겹치지 않게 **최대한 많은 회의를 배정**하는 것이 목표인 대표적인 **그리디 알고리즘** 문제입니다.

---

## 1️⃣ 문제 설명

| 항목     | 내용 |
|----------|------|
| **입력** | N개의 회의: (시작 시간, 끝나는 시간) 쌍으로 주어짐 |
| **목표** | **회의 시간이 겹치지 않게** 최대한 많은 회의를 한 개의 회의실에 배정 |
| **제약** | 한 회의가 끝난 직후 다른 회의 시작 가능 (끝나는 시간 == 다음 시작 시간 허용)

---

## 2️⃣ 핵심 아이디어 (그리디 전략)

> **“가장 빨리 끝나는 회의부터 선택”** 하면 나중에 더 많은 회의를 배치할 수 있음  
> → 즉, **“끝나는 시간 기준으로 정렬 후 배정”**

### 왜 시작 시간이 아니라 끝나는 시간으로 정렬할까?  
빠르게 끝나는 회의를 선택해야 **남는 시간 공간이 더 커짐** → 더 많은 회의 배정 가능

---

## 3️⃣ 예제 입력

```text
회의 수: 5

회의 목록 (시작, 끝):
(1, 4)
(3, 5)
(0, 6)
(5, 7)
(8, 9)
```

### 정렬 후 (끝나는 시간 기준)

```text
(1, 4)
(3, 5)
(0, 6)
(5, 7)
(8, 9)
```

### 선택 흐름

1. (1, 4) 선택 → 현재 시간 4
2. (3, 5) → 시작 3 < 4 → ❌ 스킵
3. (0, 6) → 시작 0 < 4 → ❌ 스킵
4. (5, 7) → 시작 5 ≥ 4 → ✅ 선택 → 현재 시간 7
5. (8, 9) → 시작 8 ≥ 7 → ✅ 선택 → 현재 시간 9

✅ 총 회의 수: **3개**

---

## 4️⃣ 파이썬 코드 예시

```python
def max_meetings(meetings):
    # 끝나는 시간 기준으로 정렬
    meetings.sort(key=lambda x: x[1])

    count = 0
    end_time = 0

    for start, end in meetings:
        if start >= end_time:
            count += 1
            end_time = end
    
    return count

# 입력 예시
meetings = [(1, 4), (3, 5), (0, 6), (5, 7), (8, 9)]
print(max_meetings(meetings))  # 출력: 3
```

---

## 5️⃣ 확장 가능 문제 유형

| 문제 유형                     | 설명 |
|------------------------------|------|
| 강의실 배정 (회의실 여러 개)        | 여러 회의실이 있을 때 최소 개수로 회의 배치 → 우선순위 큐 |
| 최대 활동 선택 문제 (Activity Selection) | 동일한 구조의 그리디 문제 |
| 일정 중첩 회피 문제               | 캘린더, 면접 일정 배정 등 실전에도 자주 응용됨 |

---

## 🎯 정리 요약

✔ **회의실 배정 문제는 “끝나는 시간 기준 정렬” 이 핵심**  
✔ 가장 빨리 끝나는 회의를 먼저 선택해야 **최대 개수 배정 가능**  
✔ 그리디 알고리즘의 대표 사례 중 하나, 확장하면 “여러 회의실”, “캘린더 일정”, “배치 최적화”까지 가능

