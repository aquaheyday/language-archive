# 🧮 비트 마스크(Bitmask)

**비트 마스크(Bitmask)** 는 정수의 이진 표현을 사용하여 **집합(Set)의 상태를 표현하거나 추적**하는 기법입니다.  
공간을 매우 효율적으로 사용하며, **부분 집합 탐색, 상태 추적, 최적화 문제**에 사용됩니다.

---

## 1️⃣ 문제 정의

- 어떤 항목의 **선택 여부(ON/OFF)** 또는 **상태 유무**를 **비트(0/1)** 로 표현
- 정수 `int` 하나로 여러 가지 상태를 동시에 관리할 수 있음

---

## 2️⃣ 기본 개념 예시

### 집합 {0, 1, 2, 3}의 상태를 비트로 표현

| 상태           | 이진수      | 10진수 |
|----------------|-------------|--------|
| 공집합         | 0000        | 0      |
| {1}            | 0010        | 2      |
| {0, 2}         | 0101        | 5      |
| 전체집합       | 1111        | 15     |

- 각 비트는 **해당 인덱스 원소가 있는지(1) 없는지(0)** 를 의미함
- N개의 원소는 `2^N`개의 상태를 가짐

---

## 3️⃣ 주요 연산

| 연산                 | 코드 예시               | 설명                           |
|----------------------|-------------------------|--------------------------------|
| 비트 ON (추가)        | `mask |= (1 << i)`      | i번 비트를 1로 설정              |
| 비트 OFF (제거)       | `mask &= ~(1 << i)`     | i번 비트를 0으로 설정            |
| 비트 토글 (반전)      | `mask ^= (1 << i)`      | i번 비트를 반전                  |
| 비트 체크 (존재확인)  | `mask & (1 << i)`       | i번 비트가 1인지 확인 (`> 0`)   |

---

## 4️⃣ 파이썬 코드 예제

```python
# 집합 {0, 1, 2}을 비트마스크로 관리

# 초기 상태: 공집합
mask = 0

# 원소 1 추가
mask |= (1 << 1)  # 0010 → mask = 2

# 원소 0 추가
mask |= (1 << 0)  # 0011 → mask = 3

# 원소 1 제거
mask &= ~(1 << 1)  # 0001 → mask = 1

# 원소 2가 있는지 확인
if mask & (1 << 2):
    print("2 포함됨")
else:
    print("2 없음")
```

---

## 5️⃣ 사용 예시

- **부분 집합 탐색 (전체 경우의 수)**  
  - `for mask in range(1 << n):` 로 0 ~ 2ⁿ-1까지 순회하며 상태 표현

- **DP + 상태 압축**  
  - `dp[mask][pos]` 형태로, 방문 상태 + 현재 위치를 저장

- **백트래킹 최적화**  
  - 방문 체크 배열 대신, 하나의 정수로 방문 여부 관리

---

## 6️⃣ 시간 복잡도

- 비트 연산은 모두 **O(1)**  
- 전체 집합 탐색은 최대 `2^N` → N이 작을 때만 사용 가능 (보통 N ≤ 20)

---

## 7️⃣ 주요 특징 요약

- ✅ 정수 하나로 N개의 상태 추적 가능
- ✅ 연산이 빠르고 메모리 효율 좋음
- ✅ 부분 집합 탐색, 방문 상태 추적, DP 압축에 자주 사용
- ✅ N이 크면 `2^N`으로 가능한 상태수가 기하급수적으로 늘어남 주의 필요

---

## 🎯 정리 요약

- 비트마스크는 **정수의 비트**를 이용해 상태를 추적하는 기법  
- N개의 원소 → `2^N`개의 조합 가능  
- **빠르고 효율적이며**, 특히 **조합 탐색 / DP 최적화**에 매우 유용
