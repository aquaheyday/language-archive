# 🔍 슬라이딩 윈도우 (Sliding Window)

**슬라이딩 윈도우**는 배열이나 문자열에서 **고정 또는 가변 길이의 연속된 부분(subarray)** 을 효율적으로 탐색하기 위한 알고리즘 기법입니다.

> 중복 계산 없이, 윈도우를 한 칸씩 "밀면서" 필요한 정보만 갱신함

---

## 1️⃣ 문제 정의

- 배열 또는 문자열에서 **연속된 구간에 대한 최댓값, 합, 개수 등**을 구할 때 사용
- 구간의 **범위를 슬라이딩(한 칸씩 이동)** 하면서 효율적으로 처리

---

## 2️⃣ 핵심 아이디어

- 범위 `[left, right]`를 유지하면서 오른쪽으로 이동
- 새로 들어온 값은 추가하고, 빠진 값은 제거
- **전체 배열을 한 번만 순회(`O(N)`)** 하면서 결과 계산

---

## 3️⃣ 예시 문제

### 문제
길이가 N인 배열에서 **연속된 길이 K 구간의 최댓값(또는 합)** 구하기

### 입력
```
arr = [1, 3, 2, 5, 4, 2, 1]
k = 3
```

### 예: 각 구간의 합
- [1,3,2] → 6  
- [3,2,5] → 10  
- [2,5,4] → 11  
- ...

---

## 4️⃣ 파이썬 코드 예제 (고정 길이 윈도우 합)

```python
# 고정된 길이 K의 슬라이딩 윈도우를 사용하여
# 연속된 부분 구간의 합 중 최대값을 구하는 함수
def sliding_window_sum(arr, k):
    # 초기 윈도우 (0 ~ k-1)의 합 계산
    window_sum = sum(arr[:k])
    
    # 현재까지 구한 최대 합을 초기 윈도우 합으로 설정
    max_sum = window_sum

    # 인덱스 k부터 끝까지 윈도우를 한 칸씩 오른쪽으로 이동
    for i in range(k, len(arr)):
        # 새로 들어온 값(arr[i])을 더하고,
        # 윈도우에서 빠진 값(arr[i - k])을 빼줌
        window_sum += arr[i] - arr[i - k]

        # 최대 합 갱신
        max_sum = max(max_sum, window_sum)

    # 결과 반환
    return max_sum

# 예제 입력
arr = [1, 3, 2, 5, 4, 2, 1]
k = 3

# [2, 5, 4] 부분 배열의 합 11이 최대
print(sliding_window_sum(arr, k))  # 출력: 11
```

---

## 5️⃣ 시간 복잡도

- 초기 합 계산: `O(K)`  
- 슬라이딩 과정: `O(N - K)`
- 전체 복잡도: **`O(N)`**

---

## 6️⃣ 활용 예시

- 최대/최소 부분합, 최장 조건 만족 구간
- 문자열 내 고정 길이 패턴 찾기
- 투 포인터 방식과 결합하여 **가변 길이 윈도우** 구현 가능
- 실시간 데이터 분석, 로그 스트림 처리

---

## 🎯 정리 요약

✔ 한 번의 순회로 효율적 구간 탐색  
✔ 중복 계산 없이 정보만 갱신  
✔ 투 포인터와 결합해 가변 윈도우 문제에도 활용 가능  
✔ 주로 **길이 K의 부분 배열 최적화 문제**에서 자주 사용됨
