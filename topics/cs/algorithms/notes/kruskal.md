# 🧠 알고리즘 - Kruskal: 최소 신장 트리

**최소 신장 트리(Minimum Spanning Tree, MST)** 는 **무방향 연결 그래프**에서 **모든 노드를 연결하면서 가중치 합이 최소**가 되는 트리를 의미합니다.
**Kruskal 알고리즘**은 대표적인 MST 알고리즘으로, **간선을 기준으로 정렬 → 최소 비용 간선부터 선택**하는 **그리디 알고리즘**입니다.

---

## 1️⃣ 최소 신장 트리(MST)란?

| 항목     | 설명 |
|----------|------|
| **그래프 종류** | 무방향, 연결 그래프 |
| **목표**        | 모든 정점을 연결하면서 **간선의 가중치 총합 최소화** |
| **조건**        | 사이클이 없어야 하며, 간선 수는 N - 1개 (N = 노드 수) |

---

## 2️⃣ Kruskal 알고리즘 핵심 아이디어

> **간선을 가중치 기준으로 오름차순 정렬한 뒤, 사이클이 생기지 않는 간선만 선택**하여 MST를 구성한다.

- 매 단계마다 **가장 가벼운(작은 비용의) 간선부터 선택**
- 사이클이 생기는지 여부는 **유니온-파인드(Disjoint Set)** 자료구조로 판단

---

## 3️⃣ 알고리즘 구현 흐름

1. 모든 간선을 (가중치 기준) 정렬
2. 하나씩 간선을 꺼내면서
   - 두 정점이 서로 **다른 집합**에 속하면 → 간선 선택 (MST에 포함)
   - **같은 집합이면 사이클 발생** → 간선 제외
3. N - 1개의 간선을 선택하면 MST 완성

---

## 4️⃣ 예제

Kruskal 알고리즘은 간선을 가중치 순으로 정렬한 뒤 사이클이 생기지 않는 선에서 N-1개의 간선만 선택합니다.  
(N = 노드 수)

```text
// (시작 노드, 끝 노드, 가중치)
노드 수: 4  
간선 목록:  
(1, 2, 1)  
(1, 3, 2)  
(2, 4, 5)  
(3, 4, 4)  
(2, 3, 3)

정렬된 간선:  
(1,2,1) → (1,3,2) → (2,3,3) → (3,4,4) → (2,4,5)

선택 순서:  
1. (1,2,1) ✅  
2. (1,3,2) ✅  
3. (2,3,3) ❌ (사이클)  
4. (3,4,4) ✅  
→ MST 완료 (간선 3개 선택)
```

---

## 5️⃣ 파이썬 코드 예시

```python
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])  # 경로 압축
    return parent[x]

def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

# 입력: 노드 수, 간선 정보 (a, b, cost)
nodes = 4
edges = [
    (1, 2, 1),
    (1, 3, 2),
    (2, 4, 5),
    (3, 4, 4),
    (2, 3, 3)
]

# 1. 간선 정렬
edges.sort(key=lambda x: x[2])

# 2. 유니온-파인드 초기화
parent = [i for i in range(nodes + 1)]

# 3. Kruskal 실행
total_cost = 0
for a, b, cost in edges:
    if find_parent(parent, a) != find_parent(parent, b):
        union_parent(parent, a, b)
        total_cost += cost

print("최소 신장 트리 비용:", total_cost)  # 출력: 7
```

---

## 6️⃣ 시간 복잡도

- 간선 정렬: `O(E log E)` + 유니온-파인드: 거의 `O(1)` (경로 압축 적용 시) = **`O(E log E)`**  
> (Kruskal 시간 복잡도 = 간선 정렬(`O(E log E)`) + 유니온-파인드(`O(1)`)

- 예시 1: 간선이 10개 → O(10 log 10) → 약 33번 연산
- 예시 2: 간선이 1000개 → O(1000 log 1000) → 약 10,000번 연산

---

## 🎯 정리 요약

✔ **Kruskal 알고리즘**은 간선 중심 MST 알고리즘  
✔ **그리디 전략**: 비용 작은 간선부터 선택 + 사이클 방지  
✔ **유니온-파인드 자료구조**로 사이클 체크  
✔ 효율적인 구현 가능하며, Prim보다 코드가 간단한 경우가 많음

