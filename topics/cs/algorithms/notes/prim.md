# 🌲 최소 신장 트리 - Prim 알고리즘 (프림 알고리즘)

프림 알고리즘은 **모든 정점을 최소 비용으로 연결하는 트리(MST)** 를 만드는 알고리즘입니다.  
정점 중심으로 MST를 확장해 나가며, **우선순위 큐(Heap)** 를 활용하여 효율적으로 구현할 수 있습니다.

---

## 1️⃣ 문제 정의

- 그래프의 모든 노드를 **사이클 없이**, **최소 비용으로 연결**
- **무방향 가중치 그래프**에서 사용
- 정점 수가 N일 때, 간선은 N - 1개

---

## 2️⃣ 핵심 아이디어

- 임의의 정점에서 시작
- 방문하지 않은 정점 중 **가장 가중치가 낮은 간선** 선택
- 우선순위 큐를 사용해 간선 선택을 빠르게 처리
- visited 배열로 중복 연결 방지

---

## 3️⃣ 예시

### 정점: 1, 2, 3  
### 간선 정보 (무방향 그래프)

- 1 — 2 (비용 3)  
- 1 — 3 (비용 1)  
- 2 — 3 (비용 2)

### 가능한 최소 신장 트리 구성

- 1 — 3 (1)
- 3 — 2 (2)
- 총 비용: **3**

---

## 4️⃣ 파이썬 코드 예제

```python
import heapq

def prim(n, graph):
    # 정점 방문 여부를 저장하는 배열 (1번부터 n번까지 사용)
    visited = [False] * (n + 1)

    # 최소 힙 초기화: (간선 비용, 시작 노드)
    # 처음에는 시작 노드를 1번으로 가정하고 비용 0으로 시작
    min_heap = [(0, 1)]

    # 최소 신장 트리의 총 비용
    total_cost = 0

    # 힙이 빌 때까지 반복
    while min_heap:
        # 가장 비용이 적은 간선을 꺼냄
        cost, u = heapq.heappop(min_heap)

        # 이미 방문한 정점이라면 무시
        if visited[u]:
            continue

        # 현재 정점을 방문 처리
        visited[u] = True

        # 해당 간선의 비용을 총 비용에 추가
        total_cost += cost

        # 현재 정점과 연결된 모든 간선을 확인
        for v, weight in graph[u]:
            # 아직 방문하지 않은 정점만 힙에 추가
            if not visited[v]:
                heapq.heappush(min_heap, (weight, v))

    # 모든 정점을 연결한 최소 비용 반환
    return total_cost

```

---

## 5️⃣ 입력 예시

```python
# 정점 수
n = 3

# 무방향 그래프 인접 리스트
graph = {
    1: [(2, 3), (3, 1)],
    2: [(1, 3), (3, 2)],
    3: [(1, 1), (2, 2)]
}

print(prim(n, graph))  # 출력: 3
```

---

## 6️⃣ 시간 복잡도

- 일반 구현: `O(V²)`
- 우선순위 큐 사용 시: `O(E log V)`

---

## 7️⃣ 주요 특징 요약

- ✅ 정점 중심 확장
- ✅ 최소 비용 간선 선택 (우선순위 큐)
- ✅ visited 배열로 중복 방지
- ✅ MST에 적합
- ✅ Dense 그래프에서 성능 우수

---

## 🎯 정리 요약

✔ Prim은 **정점 중심** MST 알고리즘  
✔ 항상 가장 **작은 비용 간선**을 선택  
✔ **우선순위 큐**로 `O(E log V)` 시간복잡도  
✔ **Kruskal은 간선 중심**, Prim은 **정점 중심**  
✔ **Dense 그래프일수록 Prim이 유리**  
