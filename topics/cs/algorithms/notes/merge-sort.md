# 🧠 Algorithms - 병합 정렬 (Merge Sort)

**병합 정렬(Merge Sort)** 은 배열을 **재귀적으로 반으로 분할하여**,  
각 부분 배열이 **길이 1이 될 때까지 나눈 후**, 작은 단위부터 **두 개씩 정렬하며 병합해 나가는**  
**분할 정복(Divide and Conquer)** 기반의 정렬 알고리즘입니다.

> 정렬은 나누는 도중이 아닌, **병합 과정에서** 이루어집니다.



---

## 1️⃣ 핵심 아이디어

1. 배열을 절반으로 나눈다 (분할)
2. 각각을 **재귀적으로 병합 정렬**
3. 두 정렬된 배열을 **정렬된 하나의 배열로 병합**

> 나누고 → 정렬하고 → 병합한다

---

## 2️⃣ 동작 방식 예시

초기 배열: `[5, 3, 8, 4, 2]`

#### 1 단계: 전체 분할
  ```
  [5, 3, 8, 4, 2]
  ├─ [5, 3, 8]     ← 왼쪽 먼저 처리
  └─ [4, 2]        ← 나중에 처리
  ```
#### 2 단계: 왼쪽 분할/병합
  ```
  [5, 3, 8]
  ├─ [5]
  └─ [3, 8]
      ├─ [3]
      └─ [8]
  ```
```
→ [3], [8] → 병합 → [5], [3, 8] -> 병합 [3, 5, 8]
```

#### 3 단계: 오른쪽 분할/병합
  ```
  [4, 2]
  ├─ [4]
  └─ [2]
  ```
  ```
  → 병합 → [2, 4]
  ```
#### 4 단계: 최종 병합
  ```
  [3, 5, 8] + [2, 4] → [2, 3, 4, 5, 8]
  ```

---

## 3️⃣ JavaScript 구현 예시

```js
function mergeSort(arr) {
  if (arr.length <= 1) return arr;

  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));

  return merge(left, right);
}

function merge(left, right) {
  const result = [];
  let i = 0, j = 0;

  // 작은 값부터 하나씩 병합
  while (i < left.length && j < right.length) {
    if (left[i] < right[j]) result.push(left[i++]);
    else result.push(right[j++]);
  }

  // 남은 요소 붙이기
  return result.concat(left.slice(i)).concat(right.slice(j));
}
```

---

## 4️⃣ 시간/공간 복잡도

| 항목          | 복잡도     |
|---------------|------------|
| 시간 복잡도   | O(n log n) |
| 공간 복잡도   | O(n)       |
| 안정 정렬 여부 | ✅ 안정 정렬 (Stable Sort) |

> ✅ 항상 O(n log n), 데이터 상태에 관계없이 **성능이 일정**함

---

## 5️⃣ 장점 vs 단점

| 장점                              | 단점                            |
|-----------------------------------|---------------------------------|
| 시간 복잡도가 항상 O(n log n)     | 추가 메모리 공간(O(n)) 필요       |
| 정렬 안정성(Stable Sort) 보장      | 메모리 제한 환경에선 비효율적일 수 있음 |
| 큰 데이터에 효율적                | 구현이 단순한 정렬보단 복잡함      |

---

## 🎯 정리

✔ 병합 정렬은 **"나누고 정렬하고 병합"하는 분할 정복 정렬 알고리즘**  
✔ **항상 O(n log n)** 성능으로 안정적이고 빠름  
✔ **안정 정렬**, **대용량 데이터** 처리에 적합  
✔ 단점은 **재귀 호출과 추가 메모리 사용량**  
✔ 실무에선 배열 크기에 따라 병합 정렬 또는 퀵 정렬이 선택됨
