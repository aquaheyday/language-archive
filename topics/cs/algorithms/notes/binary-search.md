# 🧠 Algorithms - 이진 탐색 (Binary Search)

**이진 탐색(Binary Search)** 은 **정렬된 배열**을 전제로,  
탐색 구간을 절반씩 나누면서 **중앙값과 비교**해 원하는 값을 찾아가는 탐색 알고리즘입니다.

> 비교 횟수를 절반으로 줄이면서 O(log n)의 빠른 속도를 자랑합니다.

---

## 1️⃣ 핵심 아이디어

1. 배열이 **오름차순 정렬되어 있어야 함**
2. **중앙값(mid)** 을 기준으로 target과 비교
   - 같으면 → 찾음
   - 작으면 → 왼쪽 탐색
   - 크면 → 오른쪽 탐색
3. 구간을 **반씩 좁혀가며** 재귀/반복

---

## 2️⃣ JavaScript 구현 예시 (반복형)

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) return mid;
    else if (arr[mid] < target) left = mid + 1;
    else right = mid - 1;
  }

  return -1; // 찾지 못한 경우
}
```

---

## 3️⃣ 예시

```js
const nums = [2, 4, 6, 8, 10, 12, 14];
binarySearch(nums, 10); // 결과: 4
binarySearch(nums, 3);  // 결과: -1
```

---

## 4️⃣ 시간/공간 복잡도

| 항목             | 복잡도     |
|------------------|------------|
| 최선              | O(1)       |
| 평균 / 최악       | O(log n)   |
| 공간 복잡도       | O(1) (반복), O(log n) (재귀) |

> 정렬된 배열에 한해 동작 가능.  
> 배열이 정렬되어 있지 않다면 **정렬 후 탐색**해야 함.

---

## 5️⃣ 장점 vs 단점

| 장점                              | 단점                         |
|-----------------------------------|------------------------------|
| 매우 빠른 탐색 속도 (O(log n))     | 정렬이 되어 있어야만 사용 가능 |
| 구현이 간단함                     | 삽입/삭제가 많은 배열엔 비효율 |
| 대규모 데이터 탐색에 적합          | 중복 값 처리 별도 로직 필요 가능 |

---

## 🎯 정리

✔ 이진 탐색은 **정렬된 배열을 절반씩 나누며 탐색**하는 알고리즘  
✔ 평균 및 최악 시간복잡도는 **O(log n)** 으로 매우 빠름  
✔ 단, **정렬이 필수**이며, 동적 배열에는 덜 유리  
✔ 탐색 효율이 중요한 곳에서는 가장 널리 쓰임

