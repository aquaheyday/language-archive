# 🎒 알고리즘 - 0/1 배낭 문제 (0/1 Knapsack Problem)

**0/1 배낭 문제**는 정해진 무게 한도를 가진 배낭에 **물건을 하나씩 담을지 말지 선택**하여  
**가치의 합이 최대가 되도록 하는 조합을 찾는 문제**입니다.

---

## 1️⃣ 문제 설명

| 항목         | 설명 |
|--------------|------|
| **입력**      | N개의 물건 (각각 무게 `w[i]`, 가치 `v[i]`), 배낭 최대 무게 `W` |
| **조건**      | 각 물건은 **한 번만 담을 수 있음** (0 또는 1번 선택) |
| **목표**      | 총 무게가 `W` 이하인 조합 중 **가치 합이 최대**가 되도록 선택 |

---

## 2️⃣ 예시

```text
물건 개수 N = 4  
최대 무게 W = 7  
물건 정보 (무게, 가치):
(6, 13)
(4, 8)
(3, 6)
(5, 12)

→ 정답: 14 (물건 2 + 3)
```

---

## 3️⃣ 점화식 (DP 식)

```text
dp[i][w] = i번째 물건까지 고려했을 때, 배낭 용량이 w일 때 얻을 수 있는 최대 가치

dp[i][w] = max(
    dp[i-1][w],                              # i번째 물건을 담지 않는 경우
    dp[i-1][w - weight[i]] + value[i]        # i번째 물건을 담는 경우
)   ← 단, w ≥ weight[i]일 때만
```

### 예시

```text
// Step 1: 물건 1번 (6kg, 13)
i\w | 0 1 2 3 4 5 6 7
---------------------
  0 | 0 0 0 0 0 0 0 0
  1 | 0 0 0 0 0 0 13 13

// Step 2: 물건 2번 (4kg, 8)
i\w | 0 1 2 3 4 5 6 7
---------------------
  0 | 0 0 0 0 0 0  0  0
  1 | 0 0 0 0 0 0 13 13
  2 | 0 0 0 0 8 8 13 13

// Step 3: 물건 3번 (3kg, 6)
i\w | 0 1 2 3 4 5 6 7
---------------------
  0 | 0 0 0 0 0 0  0  0
  1 | 0 0 0 0 0 0 13 13
  2 | 0 0 0 0 8 8 13 13
  3 | 0 0 0 6 8 8 13 14 ← ✅ 최대 가치 14

// Step 4: 물건 4번 (5kg, 12)
i\w | 0 1 2 3 4 5 6 7
---------------------
  0 | 0 0 0 0 0 0  0  0
  1 | 0 0 0 0 0 0 13 13
  2 | 0 0 0 0 8 8 13 13
  3 | 0 0 0 6 8 8 13 14
  4 | 0 0 0 6 8 12 13 14 ← 그대로 유지

// 최종
dp[4][7] = 14
```

---

## 4️⃣ 파이썬 구현 (2차원 DP)

```python
N, W = 4, 7
items = [(6,13), (4,8), (3,6), (5,12)]

dp = [[0] * (W + 1) for _ in range(N + 1)]

for i in range(1, N + 1):
    weight, value = items[i - 1]
    for w in range(W + 1):
        if w < weight:
            dp[i][w] = dp[i-1][w]
        else:
            dp[i][w] = max(dp[i-1][w], dp[i-1][w - weight] + value)

print("최대 가치:", dp[N][W])  # 출력: 14
```

---

## 5️⃣ 시간/공간 복잡도

| 항목           | 값 |
|----------------|-----|
| 시간 복잡도     | `O(N × W)` |
| 공간 복잡도     | `O(N × W)` (→ 1차원 배열로 최적화 가능)

---

## 6️⃣ 최적화 (1차원 DP로)

```python
dp = [0] * (W + 1)

for weight, value in items:
    for w in range(W, weight - 1, -1):  # 뒤에서부터 거꾸로 순회
        dp[w] = max(dp[w], dp[w - weight] + value)

print("최대 가치:", dp[W])  # 출력: 14
```

---

## 🎯 정리 요약

✔ 물건을 **한 번만 선택 가능**한 배낭 문제 → 0/1 Knapsack  
✔ **DP 점화식**은 “선택할까 말까?”의 두 가지 경우로 나눠서 계산  
✔ `O(N×W)` 시간 복잡도  
✔ 실전에서는 **1차원 배열로 최적화** 가능  
✔ 자주 등장하는 **동적 계획법 대표 문제**

