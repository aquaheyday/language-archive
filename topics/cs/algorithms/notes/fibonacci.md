# 🧠 알고리즘 - 피보나치 수열 (Fibonacci Sequence)

**피보나치 수열**은 첫 번째와 두 번째 항이 1이고, 그 이후의 항은 **앞의 두 항을 더한 값으로 정의되는 수열**입니다.

---

## 1️⃣ 정의

```text
F(1) = 1  
F(2) = 1  
F(n) = F(n-1) + F(n-2)  (n ≥ 3)
```

즉,  
```text
1, 1, 2, 3, 5, 8, 13, 21, 34, ...
```

---

## 2️⃣ 성질

| 항목 | 설명 |
|------|------|
| 점화식 | 어떤 수열의 **n번째 항을 이전 항(들)** 과의 관계로 나타낸 수학 공식 <br> `F(n) = F(n-1) + F(n-2)` |
| 재귀적 정의 | 이전 두 항을 기반으로 계산 |
| 급격히 증가 | 거의 지수 함수 형태로 증가 |
| 다양한 응용 | DP, 수학, 컴비네이션, 골드바흐 등 다양한 알고리즘 문제에서 등장 |

---

## 3️⃣ 구현 방법 3가지

### 1. 재귀 (비효율적)

```python
def fib(n):
    if n <= 2:
        return 1
    return fib(n-1) + fib(n-2)

print(fib(10))  # 출력: 55
```

> ❌ 중복 계산이 많아 `O(2^n)` → 느림

---

### 2. DP (탑다운) - 메모이제이션
> **메모이제이션이란?**  
> 한 번 계산한 결과를 저장해두고 저장된 값을 바로 사용하는 기법

```python
memo = {1: 1, 2: 1}

def fib(n):
    if n in memo:
        return memo[n]
    memo[n] = fib(n-1) + fib(n-2)
    return memo[n]
```

> `O(n)` 시간에 계산 가능

---

### 3. DP (바텀업)

```python
def fib(n):
    dp = [0, 1, 1]
    for i in range(3, n+1):
        dp.append(dp[i-1] + dp[i-2])
    return dp[n]
```

> 반복문 기반 DP. 메모리 효율적으로 가능

---

## 4️⃣ 시간 복잡도 비교

| 방법           | 시간 복잡도 | 공간 복잡도 | 설명 |
|----------------|--------------|--------------|------|
| 재귀 (단순)      | `O(2^n)`      | `O(n)`        | 중복 계산 심함 |
| DP (탑다운)     | `O(n)`        | `O(n)`        | 메모이제이션 |
| DP (바텀업)     | `O(n)`        | `O(n)` 또는 `O(1)` | 배열 or 변수 2개로 가능 |

---

## 5️⃣ 실전 응용 예시

- 계단 오르기 문제 (`n`번째 계단 오르는 방법 수)
- 동적 계획법 문제의 점화식 기반 풀이
- 조합 계산, 점화식 기반 수열 문제
- 피보나치 수를 모듈로 나눈 문제 (mod 1,000,000,007 등)

---

## 🎯 요약

✔ 피보나치 수열은 `F(n) = F(n-1) + F(n-2)`로 정의  
✔ 단순 재귀는 매우 느림 (`O(2^n)`)  
✔ 실무나 알고리즘에선 **DP(메모이제이션 or 반복문)** 사용  
✔ DP는 중복 계산을 피해서 효율적인 계산 가능

