# 🧠 Algorithms - 퀵 정렬 (Quick Sort)

**퀵 정렬(Quick Sort)** 은 기준이 되는 값을 하나 선택하고, 그 기준보다 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할한 후  
각 부분을 재귀적으로 정렬하는 **분할 정복(Divide and Conquer)** 기반의 정렬 알고리즘입니다.

---

## 1️⃣ 핵심 아이디어

1. **Pivot(기준값)** 을 하나 선택
2. 배열을 Pivot보다 **작은 값(left)**, **큰 값(right)** 으로 나눔
3. 각각 **재귀적으로 퀵 정렬**
4. 정렬된 left + pivot + right 를 병합

> 💡 "작은 건 왼쪽, 큰 건 오른쪽" → 이걸 재귀적으로 반복

---

## 2️⃣ 동작 방식 예시

초기 배열: `[5, 3, 8, 4, 2]`  
Pivot: 5 선택

1. 분할:  
   - left  = `[3, 4, 2]`  
   - right = `[8]`

2. 재귀 정렬:  
   - left → `[2, 3, 4]`  
   - right → `[8]`

3. 병합:  
   - `[2, 3, 4] + 5 + [8]` → `[2, 3, 4, 5, 8]`

---

## 3️⃣ JavaScript 구현 예시

```js
function quickSort(arr) {
  if (arr.length <= 1) return arr;

  const pivot = arr[0]; // 기준값 (간단하게 첫 번째로 선택)
  const left = [];
  const right = [];

  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < pivot) left.push(arr[i]);
    else right.push(arr[i]);
  }

  return [...quickSort(left), pivot, ...quickSort(right)];
}
```

> 💡 실전에서는 **Pivot 선택 전략(중간, 랜덤 등)** 도 매우 중요함

---

## 4️⃣ 시간/공간 복잡도

| 구분           | 복잡도     |
|----------------|------------|
| 최선            | O(n log n) |
| 평균            | O(n log n) |
| 최악 (편향 분할)| O(n²)      |
| 공간 복잡도     | O(log n)   |

> ⚠ 최악의 경우는 정렬이 거의 안 된 배열에서 pivot이 계속 한쪽에만 치우치는 경우

---

## 5️⃣ 장점 vs 단점

| 장점                                | 단점                         |
|-------------------------------------|------------------------------|
| 평균적으로 매우 빠름 (실전에서 효율 좋음) | 최악 시간복잡도는 O(n²)      |
| 추가 메모리 거의 없음 (in-place 가능) | 불안정 정렬 (Stable X)       |
| 구현이 비교적 간단함                | Pivot 선택에 따라 성능 좌우 |

---

## 🎯 정리

✔ 퀵 정렬은 **분할 정복 기반 정렬 알고리즘**  
✔ Pivot을 기준으로 작고 큰 값을 나눠서 정렬  
✔ 평균 시간복잡도는 O(n log n)으로 매우 빠름  
✔ **Pivot 선택 전략**에 따라 성능이 달라지므로 주의  
✔ 실무에서도 널리 사용되는 효율적인 정렬 방식

