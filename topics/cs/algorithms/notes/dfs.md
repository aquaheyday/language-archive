# 🧠 Algorithms - 깊이 우선 탐색 (Depth-First Search, DFS)

**깊이 우선 탐색(DFS)** 은 **한 방향으로 계속 깊게 탐색**하다가 더 이상 갈 곳이 없으면 **되돌아오는(backtrack)** 방식의 탐색 알고리즘입니다.  
**스택(Stack)** 또는 **재귀(함수 호출 스택)** 를 사용하여 구현할 수 있습니다.

> 그래프, 트리, 퍼즐 탐색 등에 활용되며  
> 경로 탐색, 사이클 감지, 조합 문제 등에서 유용합니다.

---

## 1️⃣ 핵심 아이디어

1. **현재 노드에서 갈 수 있는 노드로 계속 이동**
2. 더 이상 갈 곳이 없으면 **되돌아감 (Backtracking)**
3. 보통 **재귀**를 많이 사용하지만 **스택**으로도 구현 가능
4. **한 번 방문한 노드는 다시 방문하지 않도록 처리**

---

## 2️⃣ JavaScript 구현 예시 (재귀형)

```js
function dfs(graph, node, visited = new Set()) {
  if (visited.has(node)) return;
  visited.add(node);
  console.log(node); // 또는 결과 배열에 push

  for (const neighbor of graph[node]) {
    dfs(graph, neighbor, visited);
  }
}
```

---

## 3️⃣ 예시

#### 그래프 형태:

```
    A
   / \
  B   C
 / \   \
D   E   F
```

#### DFS 탐색 순서 (시작: A):

1. A → 시작 노드  
2. B → A에서 이어진 첫 번째 노드  
3. D → B에서 갈 수 있는 깊은 노드  
4. E → D가 끝났으니 B의 다음 자식  
5. C → B의 탐색이 끝났으니 A의 다른 자식  
6. F → C에서 갈 수 있는 노드  

#### 결과: `A → B → D → E → C → F`

---

## 4️⃣ 시간/공간 복잡도

| 항목             | 복잡도       |
|------------------|--------------|
| 시간 복잡도       | O(V + E)     |
| 공간 복잡도       | O(V)         |

> V: 노드 수, E: 간선 수  
> 재귀 호출이 깊어지면 **스택 오버플로우 주의**

---

## 5️⃣ 장점 vs 단점

| 장점                                 | 단점                             |
|--------------------------------------|----------------------------------|
| 구현이 간단하고 직관적                | 재귀 호출이 너무 깊으면 에러 발생 가능 |
| 경로 탐색, 백트래킹 문제에 강력        | 최단 거리 탐색에는 부적합           |
| 메모리 사용이 적을 수 있음            | 무한 루프 방지를 위한 visited 필요   |

---

## 🎯 정리

✔ DFS는 **한 방향으로 깊게 탐색 후, 더 이상 갈 곳이 없으면 되돌아오는** 알고리즘  
✔ **재귀 or 스택**으로 구현하며, **방문 체크 필수**  
✔ **백트래킹, 경로 찾기, 조합 탐색** 등 다양한 문제에서 핵심 알고리즘  
✔ 시간복잡도는 **O(V + E)** 로 BFS와 동일하지만, 탐색 방식은 정반대
