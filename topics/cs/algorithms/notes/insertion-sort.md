# 🧠 Algorithms - 삽입 정렬 (Insertion Sort)

**삽입 정렬(Insertion Sort)** 은 현재 요소를 **앞쪽에 이미 정렬된 부분과 비교해 알맞은 위치에 '삽입'** 하는 방식으로 정렬하는 알고리즘입니다.

> 카드 게임에서 카드를 한 장씩 손에 쥐며 정렬하는 방식과 비슷

---

## 1️⃣ 핵심 아이디어

- 배열을 왼쪽부터 하나씩 순회하면서,
- **현재 값보다 큰 값은 오른쪽으로 밀고**,  
- 현재 값을 **비교 끝난 위치에 삽입**
- 앞쪽은 항상 **정렬된 상태**를 유지하며 진행

---

## 2️⃣ 동작 방식 예시

초기 배열: `[5, 3, 8, 4, 2]`

1회차: `[3, 5, 8, 4, 2]` ← 3이 5 앞에 삽입  
2회차: `[3, 5, 8, 4, 2]` ← 8은 제자리에  
3회차: `[3, 4, 5, 8, 2]` ← 4가 8, 5보다 작으므로 앞으로  
4회차: `[2, 3, 4, 5, 8]` ← 2가 제일 앞으로

---

## 3️⃣ JavaScript 구현 예시

```js
function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let current = arr[i];
    let j = i - 1;

    // 앞에서부터 current보다 큰 값들을 한 칸씩 뒤로 이동
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j];
      j--;
    }

    // 올바른 위치에 삽입
    arr[j + 1] = current;
  }

  return arr;
}
```

---

## 4️⃣ 시간 복잡도

| 상황             | 시간 복잡도 |
|------------------|-------------|
| 최선 (거의 정렬됨) | O(n)        |
| 평균              | O(n²)       |
| 최악              | O(n²)       |
| 공간 복잡도       | O(1)        |

> 💡 **거의 정렬된 배열**에는 매우 효율적임

---

## 5️⃣ 장점 vs 단점

| 장점                              | 단점                          |
|-----------------------------------|-------------------------------|
| 구현이 쉽고 직관적                | 평균/최악 시간 복잡도는 O(n²) |
| 입력이 거의 정렬되어 있으면 빠름   | 많은 비교가 필요한 경우도 있음 |
| 제자리 정렬 (in-place, O(1) 메모리) | 대규모 데이터에는 부적합       |

---

## 🎯 정리

✔ 삽입 정렬은 **정렬된 부분에 새로운 값을 '삽입'하며 정렬을 완성하는 방식**  
✔ **거의 정렬된 배열에서 매우 효율적 (O(n))**  
✔ 공간 효율성이 좋고, 구현이 단순하여 학습/기초 구현에 적합  
✔ 대규모/무작위 데이터엔 다른 고급 정렬이 더 효율적
