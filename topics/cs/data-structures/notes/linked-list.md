# 🔗 Data Structures - 연결 리스트 (Linked List)

**연결 리스트(Linked List)** 는 각 요소가 **데이터와 다음 요소의 주소(링크)를 함께 저장**하는 **선형 자료구조**입니다.  
배열과 달리 **비연속적인 메모리 공간**을 사용하며, 동적으로 노드를 추가/삭제할 수 있습니다.

> 데이터를 한 줄로 연결해 나가는 구조  
> "칸칸이 이어진 기차처럼" 노드들이 포인터로 연결되어 있음

---

## 1️⃣ 연결 리스트의 구조

- 각 요소를 **노드(Node)** 라고 부름  
- 각 노드는 다음 노드를 가리키는 **포인터(링크)** 를 가짐  
- 리스트의 시작은 **head**, 끝은 **null** (종료를 의미)

#### 예시 (단일 연결 리스트)
```
[1] → [2] → [3] → null
```


---

## 2️⃣ 연결 리스트의 종류

| 종류           | 설명 |
|----------------|------|
| **단일 연결 리스트 (Singly Linked List)** | 한 방향으로만 연결 (next 포인터만 있음) |
| **이중 연결 리스트 (Doubly Linked List)** | 앞뒤 모두 연결 (next + prev 포인터) |
| **원형 연결 리스트 (Circular Linked List)** | 마지막 노드가 다시 첫 노드를 가리킴 |

---

## 3️⃣ 연결 리스트 vs 배열

| 항목        | 배열 (Array)         | 연결 리스트 (Linked List)    |
|-------------|----------------------|-------------------------------|
| 메모리 구조  | 연속된 공간            | 비연속적인 공간                |
| 인덱스 접근  | ✅ O(1)               | ❌ O(n) (앞에서부터 순회 필요) |
| 삽입/삭제    | ❌ O(n)               | ✅ O(1) (노드만 연결하면 됨)    |
| 크기 변경    | ❌ 불가 (정적 배열)     | ✅ 가능 (노드 동적 생성/삭제)   |

---

## 4️⃣ 연결 리스트 주요 연산과 시간 복잡도

| 연산             | 시간 복잡도 |
|------------------|--------------|
| 접근 (Access)     | O(n)         |
| 탐색 (Search)     | O(n)         |
| 앞에 삽입         | O(1)         |
| 뒤에 삽입         | O(n) (Tail 없으면) |
| 중간 삽입/삭제     | O(n)         |

> 특정 위치를 알고 있어야 O(1) 삽입/삭제 가능  
> 접근 성능은 배열보다 떨어지지만 **삽입/삭제는 효율적**

---

## 5️⃣ 연결 리스트의 장점

- 메모리 **효율적 사용** (필요할 때마다 동적 할당)  
- **삽입/삭제가 빠름** (특히 앞부분)  
- 배열처럼 전체 재배열 필요 없음  
- 크기 제한 없음

---

## 6️⃣ 연결 리스트의 단점

- **임의 접근 불가** (인덱스 X → 순차 접근만 가능)  
- **추가 포인터 저장** 필요 → 메모리 사용량 증가  
- 구현 복잡도 ↑ (포인터 관리, 예외 처리 등)

---

## 7️⃣ 활용 예시

- 스택, 큐, 그래프 인접 리스트 구현  
- 메모리 할당 시스템 (Heap Free List)  
- Undo/Redo 기능 구현 (이중 연결 리스트)

---

## 🎯 정리 요약

✔ 연결 리스트는 **포인터로 노드를 연결한 선형 구조**  
✔ **삽입/삭제에 유리**하고, 메모리 **동적 관리 가능**  
✔ 배열보다 접근은 느리지만, 구조적 유연성이 높음  
✔ **단일 / 이중 / 원형** 등 다양한 형태로 구현 가능

