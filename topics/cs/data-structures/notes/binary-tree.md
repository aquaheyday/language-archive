# 🌳 Data Structures - 이진 트리 (Binary Tree)

**이진 트리(Binary Tree)** 는 **각 노드가 최대 두 개의 자식 노드를 가지는 트리 구조**입니다.

> 트리(Tree) 자료구조의 한 종류로, 왼쪽 자식(left)과 오른쪽 자식(right)으로 구성

---

## 1️⃣ 이진 트리의 주요 특징

- 각 노드는 **최대 2개의 자식**을 가짐 (left, right)
- 순환(cycle)이 없는 **계층적 구조**
- 루트(Root)에서 시작하여 아래로 확장
- 완전 이진 트리, 포화 이진 트리, 편향 이진 트리 등 다양한 형태 존재

---

## 2️⃣ 주요 용어 정리

| 용어            | 설명                                      |
|-----------------|-------------------------------------------|
| Root Node       | 트리의 시작 노드 (부모가 없음)            |
| Leaf Node       | 자식 노드가 없는 노드                     |
| Parent / Child  | 부모-자식 관계 (연결된 상하 노드)         |
| Sibling         | 같은 부모를 가진 노드                     |
| Subtree         | 하나의 노드를 루트로 하는 하위 트리       |
| Height          | 트리의 루트에서 가장 깊은 노드까지의 거리 |
| Depth           | 루트에서 특정 노드까지의 거리             |
| Level           | 노드의 계층 수준 (루트는 0 또는 1)        |

---

## 3️⃣ 이진 트리의 종류

| 종류              | 설명                                                         |
|-------------------|--------------------------------------------------------------|
| 포화 이진 트리     | 모든 레벨이 완전히 채워진 트리                                |
| 완전 이진 트리     | 마지막 레벨을 제외하고 왼쪽부터 노드가 꽉 채워진 구조         |
| 편향 이진 트리     | 노드가 한쪽 방향(왼쪽 또는 오른쪽)으로만 확장된 구조          |
| 정 이진 트리       | 모든 노드가 0개 또는 2개의 자식을 가짐                        |
| 균형 이진 트리     | 모든 서브트리의 높이 차이가 1 이하인 트리 (예: AVL, Red-Black) |

---

## 4️⃣ 주요 연산

| 연산              | 설명                                       |
|-------------------|--------------------------------------------|
| 삽입 (Insert)     | 특정 규칙에 따라 노드를 추가                |
| 삭제 (Delete)     | 노드를 제거하고 구조 유지                   |
| 순회 (Traversal)  | 노드를 특정 순서로 방문 (DFS / BFS)        |

---

## 5️⃣ 트리 순회 방식 (Traversal)

### 1) 깊이 우선 탐색 (DFS)

| 방식               | 순서                  |
|--------------------|------------------------|
| 전위 순회 (Preorder) | 루트 → 왼쪽 → 오른쪽     |
| 중위 순회 (Inorder)  | 왼쪽 → 루트 → 오른쪽     |
| 후위 순회 (Postorder)| 왼쪽 → 오른쪽 → 루트     |

```
예시 트리:
      A
     / \
    B   C
   / \
  D   E

Preorder  : A B D E C  
Inorder   : D B E A C  
Postorder : D E B C A
```

---

### 2) 너비 우선 탐색 (BFS)

- 레벨 순서대로 노드를 탐색
- Queue 자료구조 사용

```
Level Order : A B C D E
```

---

## 6️⃣ 구현 방식

### 1) 노드 기반 (연결 구조)

```
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
```

---

### 2) 배열 기반 (완전 이진 트리의 경우)

- 인덱스를 활용해 자식 노드 계산  
  - 왼쪽 자식: 2 * i  
  - 오른쪽 자식: 2 * i + 1

---

## 7️⃣ 시간 복잡도

| 연산       | 평균 시간 복잡도 | 최악의 경우 |
|------------|------------------|--------------|
| 탐색, 삽입, 삭제 | O(log n)          | O(n)         |

> 균형이 맞지 않으면 선형 시간까지 증가할 수 있음  
> AVL, Red-Black Tree 등으로 보완 가능

---

## 8️⃣ 활용 사례

- 이진 탐색 트리(BST), 힙(Heap), 세그먼트 트리
- 파싱 트리 / 수식 트리
- 파일 시스템 구조
- 게임 트리 (Minimax)
- 네트워크 라우팅
- 데이터베이스 인덱싱 (B-Tree)
- 트리 기반 정렬 (Heap Sort)

---

## 9️⃣ 정리 요약 🎯

✔ 이진 트리는 **노드당 최대 2개의 자식을 가지는 트리**  
✔ 다양한 순회 방식 (Preorder, Inorder, Postorder, Level Order)  
✔ 일반적으로 **O(log n)** 시간 복잡도  
✔ 탐색, 구조화된 데이터 저장, 계산식 표현 등 다방면에 활용
