# 🧠 Computer Architecture - 명령어 사이클 (Instruction Cycle)

**명령어 사이클 (Instruction Cycle)** 은 CPU가 **메모리에 저장된 명령어를 가져와 실행하고, 그 결과를 저장하는 일련의 과정**입니다.  
모든 컴퓨터 명령어는 이 과정을 거쳐 수행됩니다.

---

## 1️⃣ 명령어 사이클의 주요 단계

| 단계       | 설명 |
|------------|------|
| 1. Fetch   | 메모리에서 명령어를 읽어 옴 (Program Counter → Memory) |
| 2. Decode  | 명령어 해석 (어떤 연산인지, 어떤 피연산자인지 분석) |
| 3. Execute | 명령어 실행 (ALU 연산, 데이터 이동 등) |
| 4. Write Back | 결과를 저장 (레지스터나 메모리로 결과 기록) |

> 이 사이클을 **Fetch → Decode → Execute → Write Back** 과정이라고도 함

---

## 2️⃣ 각 단계 자세히 보기

### 1. Fetch (가져오기)
- **Program Counter (PC)** 가 가리키는 주소의 명령어를 메모리에서 가져옴
- 가져온 명령어는 **Instruction Register (IR)** 에 저장됨
- PC는 자동으로 다음 명령어 주소로 증가

### 2. Decode (해석)
- IR에 저장된 명령어를 분석
- 연산 코드(Op-code)와 피연산자 정보 추출
- 제어장치(CU)가 어떤 동작을 할지 결정

### 3. Execute (실행)
- 명령어의 종류에 따라 ALU가 연산 수행
- 데이터 이동, 연산, 분기 처리 등

### 4. Write Back (결과 기록)
- 실행 결과를 **레지스터**나 **메모리**에 저장
- 이 단계는 간단한 명령어일 경우 생략되기도 함

---

## 3️⃣ 시각적 흐름

```
[PC] → Fetch → Decode → Execute → Write Back → [다음 명령어]
```

- 모든 명령어는 이 과정을 반복함 (명령어 주기 반복)

---

## 4️⃣ 예시: ADD 명령어 실행 흐름

```assembly
ADD R1, R2
```

1. **Fetch**: 명령어 `ADD R1, R2`를 메모리에서 가져옴  
2. **Decode**: 이 명령어는 R1과 R2를 더하는 것이라고 해석  
3. **Execute**: ALU가 R1 + R2 수행  
4. **Write Back**: 결과를 R1에 저장

---

## 5️⃣ 명령어 사이클과 CPU 성능

- 이 사이클을 빠르게 반복할수록 CPU 성능이 높아짐
- 고속화 기법:  
  - **파이프라이닝 (Pipelining)**  
  - **캐시 메모리 사용**  
  - **분기 예측, 명령어 병렬 처리 등**

---

## 🎯 정리 요약

✔ **명령어 사이클**은 CPU가 명령어를 처리하는 기본 절차  
✔ 구성 단계: **Fetch → Decode → Execute → Write Back**  
✔ 반복적으로 수행되며 모든 프로그램 실행의 기반이 됨  
✔ 명령어 사이클을 최적화하는 것이 **CPU 성능 향상의 핵심**

