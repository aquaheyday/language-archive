# ⚙️ CPU 스케줄링 알고리즘

**CPU 스케줄링 알고리즘**은 준비 큐에 있는 프로세스들 중 어떤 것을 CPU에 할당할지를 결정하는 규칙입니다.  
각 알고리즘은 처리 효율, 응답 속도, 공정성 등에서 차이가 있으며, 상황에 따라 선택이 달라집니다.

---

## 1️⃣ FCFS (First-Come, First-Served)

| 항목       | 설명 |
|------------|------|
| 방식       | 도착한 순서대로 처리 (선입선출) |
| 유형       | 비선점형 |
| 장점       | 구현이 간단하고 직관적 |
| 단점       | 짧은 작업이 긴 작업 때문에 지연되는 **Convoy Effect** 발생 |

#### 예시

```text
도착 순서: P1(10ms), P2(3ms), P3(2ms)

Gantt 차트:
| P1 |        P2        |     P3     |
|----|------------------|------------|
0    10                 13           15
```

- 평균 대기 시간: (0 + 10 + 13) / 3 = 7.66ms

---

## 2️⃣ SJF (Shortest Job First)

| 항목       | 설명 |
|------------|------|
| 방식       | 실행 시간이 가장 짧은 프로세스 먼저 실행 |
| 유형       | 비선점형 |
| 장점       | 평균 대기 시간 최소화 |
| 단점       | 실행 시간을 예측해야 함, 긴 작업은 기아 발생 가능성 있음 |

#### 예시

```text
P1(8ms), P2(4ms), P3(2ms)

정렬: P3 → P2 → P1

Gantt 차트:
| P3 |    P2    |        P1        |
|----|----------|------------------|
0    2          6                  14
```

- 평균 대기 시간: (0 + 2 + 6) / 3 = 2.66ms

---

## 3️⃣ SRTF (Shortest Remaining Time First)

| 항목       | 설명 |
|------------|------|
| 방식       | 남은 실행 시간이 가장 짧은 프로세스 우선 |
| 유형       | 선점형 |
| 장점       | 짧은 작업 우선 처리, 평균 대기 시간 ↓ |
| 단점       | 긴 작업은 기아 가능성 있음, 구현 복잡 |

#### 예시

```text
P1(8ms, t=0), P2(4ms, t=1), P3(2ms, t=2)

Gantt 차트:
| P1 | P2 | P3 | P2 | P1 |
|----|----|----|----|----|
0    1    3    5    6    10
```

---

## 4️⃣ Round Robin (RR)

| 항목       | 설명 |
|------------|------|
| 방식       | 모든 프로세스에게 Time Quantum만큼 CPU를 순차적으로 할당 |
| 유형       | 선점형 |
| 장점       | 공정함, 사용자 응답성 ↑ |
| 단점       | 컨텍스트 스위칭 많음, Time Quantum 설정이 중요 |

#### 예시 (Time Quantum = 4ms)

```text
P1(10ms), P2(4ms), P3(5ms)

Gantt 차트:
| P1 | P2 | P3 | P1 | P3 | P1 |
|----|----|----|----|----|----|
0    4    8    12   16   17   19
```

- 평균 대기 시간 계산은 복잡하지만 공정한 분배가 보장됨

---

## 5️⃣ Priority Scheduling

| 항목       | 설명 |
|------------|------|
| 방식       | 우선순위가 높은 프로세스 먼저 실행 |
| 유형       | 선점형 / 비선점형 둘 다 가능 |
| 장점       | 중요한 작업을 먼저 처리 가능 |
| 단점       | 낮은 우선순위 작업이 **기아(Starvation)** 가능

#### 예시 (숫자가 낮을수록 우선순위 높음)

```text
P1(10ms, 우선순위 2),  
P2(1ms, 우선순위 1),  
P3(2ms, 우선순위 3)

Gantt 차트 (선점형):
| P2 |         P1         | P3 |
|----|--------------------|----|
0    1                   11   13
```

---

## 6️⃣ Multilevel Queue (MLQ)

| 항목       | 설명 |
|------------|------|
| 방식       | 프로세스를 우선순위나 유형에 따라 여러 큐로 분리 |
| 유형       | 보통 비선점형 |
| 장점       | 프로세스 성격별 분리 처리 |
| 단점       | 큐 간 이동 불가 (고정형일 경우)

#### 예시

```text
- 큐 1: 시스템 프로세스 (우선순위 높음)
- 큐 2: 사용자 인터랙티브 프로세스
- 큐 3: 백그라운드 작업

→ 큐1이 비면 그때서야 큐2 처리
```

---

## 7️⃣ Multilevel Feedback Queue (MLFQ)

| 항목       | 설명 |
|------------|------|
| 방식       | 여러 레벨의 큐 + **큐 간 이동 가능**, 최근 행동 기반 우선순위 조절 |
| 유형       | 선점형 |
| 장점       | 다양한 프로세스 성격에 유연하게 대응 |
| 단점       | 구현 복잡, 튜닝 필요

#### 특징

- 새 프로세스는 높은 우선순위 큐부터 시작
- CPU를 오래 쓰면 낮은 큐로 이동
- I/O 중심 작업은 높은 우선순위 유지

---

## 🎯 정리 요약

| 알고리즘        | 선점형 | 평균 대기 시간 | 응답성 | 공정성 | 특징 |
|-----------------|--------|----------------|--------|--------|------|
| FCFS            | ❌     | 높음           | 낮음   | 낮음   | 구현 쉬움 |
| SJF             | ❌     | 최적           | 낮음   | 낮음   | 기아 발생 가능 |
| SRTF            | ✅     | 최적에 가까움  | 좋음   | 낮음   | 구현 복잡 |
| RR              | ✅     | 중간           | 빠름   | 높음   | 타임퀀텀 조절 |
| Priority        | ⛔/✅   | 중간           | 중간   | 낮음   | Aging 필요 |
| MLQ             | ❌     | 다양함         | 다양함 | 중간   | 유형별 큐 고정 |
| MLFQ            | ✅     | 좋음           | 좋음   | 높음   | 실전 OS 적용 다수 |


✔ **현대 운영체제는 여러 알고리즘을 혼합**하거나 MLFQ 방식 사용
