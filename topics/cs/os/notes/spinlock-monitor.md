# 🌀 Spinlock & Monitor

운영체제에서 **동기화(Synchronization)** 를 구현하는 방법 중, **Spinlock**과 **Monitor**는 각각 **저수준/고수준** 동기화 기법을 대표합니다.

---

## 1️⃣ Spinlock (스핀락)

| 항목       | 설명 |
|------------|------|
| **정의**   | 잠금이 풀릴 때까지 **CPU를 쉬지 않고 루프(Spin)하며 대기**하는 락 |
| **특징**   | 간단한 구현, 빠른 락/언락, **문맥 전환이 없음** |
| **사용 환경** | 락을 잠깐만 잡는 임계구역 (짧은 작업), 멀티코어 시스템에서 유리 |
| **단점**   | 락이 오래 걸릴 경우 CPU 낭비 (Busy Waiting) 발생 |

### 작동 방식 예시 (의사코드)
```c
while (lock == 1) {
    // Spin: 락이 해제되기를 계속 확인
}
lock = 1;  // 락 획득
// 임계구역
lock = 0;  // 락 해제
```

---

## 2️⃣ Monitor (모니터)

| 항목       | 설명 |
|------------|------|
| **정의**   | **동기화된 접근을 보장**하는 **고수준 동기화 추상화 구조** |
| **구성 요소** | 공유 자원, 동기화 메서드, 조건 변수 (Condition Variable) |
| **특징**   | **언어나 시스템 차원**에서 제공 (ex. Java `synchronized`, Python `with Lock`) |
| **장점**   | 코드 구조 명확, Race Condition 방지, 자동 락/해제 |
| **단점**   | 시스템/언어 종속, 저수준 제어 어려움 |

### 작동 방식 예시 (Java)
```java
class SharedResource {
    synchronized void criticalSection() {
        // 임계구역: 자동 락 & 해제
    }
}
```

---

## 3️⃣ Spinlock vs Monitor 비교

| 항목           | Spinlock                          | Monitor                          |
|----------------|-----------------------------------|----------------------------------|
| **수준**       | 저수준(Low-Level)                 | 고수준(High-Level)               |
| **CPU 자원**   | 사용 (Busy Waiting)               | 대기 중 CPU 사용 안 함           |
| **성능**       | 짧은 락에는 빠름                  | 상황에 따라 다름                 |
| **문맥 전환**  | 없음                              | 있음 (스레드 블로킹/스케줄링)   |
| **사용 환경** | 멀티코어, 짧은 락                 | 언어/프레임워크 기반 동기화에 적합 |
| **구현 복잡도**| 단순                              | 상대적으로 복잡 (내부 자동 제어) |
| **예시**       | 커널 락, 장치 드라이버 등         | Java 동기화, C# lock, Python threading |

---

## 🎯 정리 요약

✔ **Spinlock**은 락이 풀릴 때까지 계속 루프를 돌며 기다리는 **바쁜 대기 방식**  
✔ **Monitor**는 공유 자원 접근을 자동으로 제어하는 **고수준 추상화 동기화 기법**  
✔ Spinlock은 **짧고 빠른 임계구역**, Monitor는 **직관적이고 안정적인 접근 제어**에 적합  
✔ 언어 지원 여부에 따라 Monitor는 코드 구조상 사용이 쉬움 (ex. Java, Python)

