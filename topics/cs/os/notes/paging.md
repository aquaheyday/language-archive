# 📦 페이징 & 페이지 교체 알고리즘

운영체제에서 **페이징(Paging)** 은 메모리를 관리하는 대표적인 기법이며,  
**페이지 교체(Page Replacement)** 는 메모리가 가득 찼을 때 어떤 데이터를 내보낼지를 결정하는 전략입니다.  
가상 메모리, 프로세스 메모리 격리, 메모리 단편화 해결 등과 밀접한 관계가 있습니다.

---

## 1️⃣ 페이징(Paging)이란?

| 항목       | 설명 |
|------------|------|
| 목적       | 물리 메모리와 가상 주소 공간을 효과적으로 매핑 |
| 방식       | 가상 주소 공간과 물리 주소 공간을 **고정 크기 블록(페이지)** 단위로 분할 |
| 단위       | 가상 주소: 페이지(Page), 물리 메모리: 프레임(Frame) |
| 특징       | 외부 단편화 해결, 내부 단편화 발생 가능 |

---

## 2️⃣ 페이징 작동 원리

```text
가상 주소 = [페이지 번호] + [오프셋]

1. 페이지 번호를 이용해 페이지 테이블에서 물리 프레임 번호 확인
2. 해당 프레임의 오프셋을 더해 물리 주소 계산
3. 해당 프레임이 메모리에 없으면 → Page Fault → 디스크에서 로드
```

---

## 3️⃣ 페이지 테이블 (Page Table)

| 항목       | 설명 |
|------------|------|
| 역할       | 가상 페이지 번호 ↔ 물리 프레임 번호 매핑 정보 저장 |
| 위치       | 커널 메모리에 존재 |
| 문제점     | 페이지 수가 많으면 테이블이 커짐 → 다단계 페이지 테이블 사용 |

> 다단계 페이지 테이블 (Multilevel Page Table): 전체 페이지 테이블을 한꺼번에 만들지 않고, 필요한 부분만 "계층적으로" 만듦

---

## 4️⃣ 페이지 폴트 (Page Fault)

| 항목       | 설명 |
|------------|------|
| 정의       | 가상 주소에 해당하는 페이지가 **물리 메모리에 없을 때 발생** |
| 처리 방식  | 디스크(스왑 공간)에서 해당 페이지를 메모리로 불러옴 |
| 성능 영향  | 잦은 Page Fault는 시스템 속도 급격히 저하시킴 (Thrashing 위험) |

---

## 5️⃣ 페이지 교체 알고리즘 (Page Replacement)

메모리가 가득 찬 상태에서 새로운 페이지를 불러올 경우, **어떤 기존 페이지를 제거할지 결정**하는 알고리즘

### 1. FIFO (First-In, First-Out)

| 항목       | 설명 |
|------------|------|
| 특징 | 가장 오래된 페이지 제거 |
| 장점 | 구현이 간단함 |
| 단점 | 오래됐다고 꼭 덜 사용된 건 아니여서 삭제시 성능 저하 가능 |

#### 예시
```text
프레임 3개, 입력: A B C A B D  
→ 교체 순서: A B C → D replaces A  
```

---

### 2. LRU (Least Recently Used)

| 항목       | 설명 |
|------------|------|
| 특징 | 가장 오랫동안 사용되지 않은 페이지 제거 |
| 장점 | 실제 사용 기반으로 교체 결정 → 성능 우수 |
| 단점 | 구현이 복잡함 |
| 근사 알고리즘 | Clock (Second Chance), Aging 등 |

#### 예시
```text
A B C A D  
→ D replaces B (B가 가장 오래 안 쓰였음)
```

---

### 3. Optimal (OPT)

| 항목       | 설명 |
|------------|------|
| 특징 | 앞으로 가장 오랫동안 사용되지 않을 페이지 제거 (이론상 최적) |
| 장점 | 페이지 폴트 수 최소 |
| 단점 | 실제 미래의 접근을 예측할 수 없으므로 **실제로 사용 불가능** (비교용) |

---

### 4. Clock (Second Chance)

| 항목       | 설명 |
|------------|------|
| 특징 | LRU의 근사 알고리즘, "사용 비트"로 페이지 회전하며 체크 |
| 장점 | 구현이 쉽고 LRU에 근접한 성능 |
| 동작 방식 |
```text
- 페이지가 교체 대상이면 → 참조 비트 확인  
- 비트가 1이면 → 0으로 만들고 pass  
- 비트가 0이면 → 교체
```

---

## 6️⃣ 페이지 교체 비교표

| 알고리즘 | 정확도 | 구현 난이도 | Page Fault 수 | 실제 사용 여부 |
|----------|--------|-------------|----------------|-----------------|
| FIFO     | 낮음   | 쉬움        | 높을 수 있음   | 가끔 사용       |
| LRU      | 높음   | 중간~어려움 | 낮음           | ✔ 많이 사용됨   |
| OPT      | 최고   | 불가능      | 최소           | ❌ 이론 전용     |
| Clock    | 중간   | 쉬움        | LRU에 근접     | ✔ 실전 적용  |

---

## 🎯 요약 정리

✔ **페이징**은 메모리를 페이지 단위로 관리하여 단편화를 줄이고 효율적인 가상 메모리 구현 가능  
✔ **페이지 교체 알고리즘**은 Page Fault 발생 시 교체할 페이지를 선택하는 전략  
✔ **LRU**는 성능이 가장 우수하지만 구현이 복잡  
✔ **Clock 알고리즘**은 LRU의 좋은 대안으로 실제 OS에서 널리 사용됨  
✔ **Optimal**은 비교/이론용 기준

