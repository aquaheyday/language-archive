# 💥 Deadlock (교착 상태)

**Deadlock(데드락)** 은 둘 이상의 프로세스가 **서로가 가진 자원을 기다리면서 무한 대기 상태에 빠지는 현상**을 말합니다.  
데드락이 발생하면 시스템이 멈추게 되며, OS 차원에서 이를 **예방, 회피, 탐지, 복구**하는 메커니즘이 필요합니다.

---

## 1️⃣ Deadlock 정의

| 항목       | 설명 |
|------------|------|
| **정의**   | 둘 이상의 프로세스가 **자원을 서로 기다리며** 무한 대기 상태에 빠짐 |
| **결과**   | 해당 프로세스들 모두 실행 불가, 시스템 자원 낭비 |
| **예시**   | A가 프린터를 점유, B가 디스크를 점유한 상태에서 서로의 자원을 요청하고 대기 |

---

## 2️⃣ Deadlock 발생 조건 (Coffman 조건)

데드락은 아래 **4가지 조건이 모두 만족될 때** 발생합니다:

| 조건 번호 | 조건명              | 설명 |
|-----------|----------------------|------|
| 1        | **상호 배제 (Mutual Exclusion)** | 자원은 한 번에 하나의 프로세스만 사용 가능 |
| 2         | **점유 대기 (Hold and Wait)**    | 자원을 점유한 상태에서 추가 자원 요청하며 대기 |
| 3         | **비선점 (No Preemption)**       | 자원을 강제로 회수할 수 없음 |
| 4         | **환형 대기 (Circular Wait)**    | 프로세스들이 서로 **자원을 순환적으로 대기** |

> **4가지 중 하나라도 제거하면 데드락은 발생하지 않음**

---

## 3️⃣ Deadlock 예시 (도식)

```
[ P1 ] → 자원 A 점유, 자원 B 요청
[ P2 ] → 자원 B 점유, 자원 A 요청

P1 ---wait---> B
P2 ---wait---> A
=> 서로 기다리며 영원히 대기 (Deadlock)
```

---

## 4️⃣ Deadlock 처리 방법

| 방법         | 설명 |
|--------------|------|
| **예방 (Prevention)** | 4가지 조건 중 최소 하나를 제거 (ex. 자원 선점, 순서 부여 등) |
| **회피 (Avoidance)** | 데드락 가능성 있는 상태 자체를 피함 (ex. Banker's Algorithm) |
| **탐지 (Detection)** | 데드락 발생 여부를 감지하고, 복구 수행 |
| **복구 (Recovery)** | 데드락이 발생하면 프로세스를 종료하거나 자원을 회수 |

---

## 5️⃣ Banker's Algorithm (회피 기법)

| 항목       | 설명 |
|------------|------|
| **기본 개념** | 자원의 최대 사용량을 미리 알고, 안전 상태(Safe State)를 유지하도록 관리 |
| **전제 조건** | 프로세스가 **최대 자원 요구량**을 미리 알려줘야 함 |
| **단점**     | 계산 복잡, 실시간 시스템에 부적합 |

---

## 6️⃣ Deadlock 탐지 예시 (자원 할당 그래프)

```
프로세스 → 자원 요청
자원 → 프로세스 할당

순환(Cycle)이 발생하는 경우 → Deadlock 가능성 있음
```

예:
```
P1 → R1 → P2 → R2 → P1  → 🔁 순환 발생 = Deadlock
```

---

## 🎯 정리 요약

✔ **Deadlock**은 자원 경쟁 중 **무한 대기 상태에 빠진 현상**  
✔ **4가지 발생 조건**: 상호 배제, 점유 대기, 비선점, 환형 대기  
✔ 해결 방법: **예방, 회피, 탐지, 복구**  
✔ **Banker's Algorithm**은 회피 기법의 대표 예  
✔ 순환 대기는 자원 그래프 분석으로 탐지 가능

