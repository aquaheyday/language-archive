# ☁️ 시스템 설계 - 서버리스 아키텍처 (Serverless Architecture)

**서버리스(Serverless)** 는 서버를 직접 구축하거나 관리하지 않고, **클라우드에서 필요한 만큼 실행되는 함수 단위 컴퓨팅 모델**입니다.  
"서버가 없는" 게 아니라 **서버 관리를 사용자 대신 클라우드가 해주는 모델**이에요.

---

## 1️⃣ 서버리스란?

| 항목       | 설명 |
|------------|------|
| **정의**   | 서버 인프라를 신경 쓰지 않고, **코드 실행에 집중**할 수 있는 클라우드 기반 실행 모델 |
| **핵심 개념** | **이벤트 기반 함수 실행**, **자동 확장**, **사용한 만큼 과금(Pay-per-use)** |
| **예시**   | 사용자가 이미지 업로드 → 자동으로 리사이징 함수 실행 → 결과 저장

---

## 2️⃣ 서버리스 구성 요소

| 구성 요소         | 설명 |
|------------------|------|
| **FaaS (Function as a Service)** | 이벤트가 발생할 때 함수 단위로 실행되는 서버리스 핵심 (ex. AWS Lambda) |
| **API Gateway**    | 클라이언트 요청을 함수에 전달하는 HTTP 엔드포인트 역할 |
| **이벤트 소스**    | 트리거 역할을 하는 서비스 (예: S3, DynamoDB, SQS 등) |
| **스토리지/DB**    | 서버리스 환경에서 함께 쓰이는 저장소 (S3, DynamoDB 등) |
| **IAM / 보안 정책** | 최소 권한 원칙에 따른 함수 접근 제어 필수 |

---

## 3️⃣ 서버리스 동작 흐름

```text
[Client Request]              # 사용자 요청 (예: 웹, 모바일, IoT 등)
       |
       v
[API Gateway]                 # 엔드포인트 관리, 인증, 요청 라우팅
       |
       v
[Serverless Function (FaaS)]  # 예: AWS Lambda, GCP Cloud Function 등
       |
       |-- 비즈니스 로직 수행 (예: 이미지 리사이징, 알림 발송 등)
       |
       v
[External Service Access]     # 필요 시 연동 (아래 중 하나 이상)
   ├── [Database]             # DynamoDB, Aurora Serverless 등
   ├── [Object Storage]       # S3, GCS 등
   ├── [Message Queue]        # SQS, Pub/Sub 등
   └── [3rd-party API]        # 외부 결제/메일 서비스 등

(필요 시 결과 반환)
       |
       v
[Response to Client]          # 클라이언트에 결과 응답 (JSON, 상태 코드 등)
```

---

## 4️⃣ 서버리스의 장점

| 장점                         | 설명 |
|------------------------------|------|
| **서버 관리 불필요**          | OS, 인프라, 스케일링 등 자동 처리 |
| **자동 확장 (Auto Scaling)** | 요청 수에 따라 함수 인스턴스 자동 증가/감소 |
| **비용 효율성**               | 사용한 만큼만 과금 (Idle 시 비용 없음) |
| **빠른 배포 및 개발 속도**   | 비즈니스 로직 단위에 집중 가능 |
| **높은 가용성**               | 클라우드의 내장 인프라 이용

---

## 5️⃣ 서버리스의 단점

| 단점                          | 설명 |
|-------------------------------|------|
| **콜드 스타트 지연**           | 오랜 시간 호출 없으면 첫 실행 지연 가능 |
| **디버깅/로컬 테스트 어려움**   | 로컬에서 전체 흐름 테스트 복잡 |
| **상태 저장 어려움**           | 상태를 유지하려면 외부 저장소 필요 |
| **제한된 실행 시간/자원**      | 타임아웃, 메모리 제한 존재 (ex. Lambda: 기본 15분) |
| **복잡한 아키텍처 가능성**     | 함수 수가 많아지면 관리 어려움 ("람다 헬")

---

## 6️⃣ 서버리스 vs 전통적 아키텍처

| 항목           | 서버리스                          | 전통적 서버 (VM, 컨테이너 등)        |
|----------------|------------------------------------|--------------------------------------|
| **인프라 관리** | 없음 (클라우드에서 자동 처리)       | 직접 관리 필요 (서버 구성, OS 업데이트 등) |
| **확장성**     | 자동 확장                          | 수동 또는 오토스케일링 설정 필요       |
| **비용 구조**  | 요청 기반 과금                     | 인스턴스 단위 고정 과금               |
| **배포 단위**  | 함수 단위                          | 애플리케이션 또는 서비스 단위          |
| **유지보수**   | 적음                               | 많음 (서버 보안, 패치 등)

---

## 7️⃣ 서버리스 활용 예시

- 이미지/영상 업로드 후 자동 변환
- 비회원 주문 처리, 인증 코드 발송
- 실시간 알림/푸시 메시지 전송
- 간단한 ETL (데이터 변환, 집계)
- 크론 작업 (예약 스케줄 실행)
- 챗봇/웹훅 응답 처리

---

## 8️⃣ 주요 서버리스 기술 스택

| 클라우드       | FaaS 서비스      | 연동 가능한 서비스 예시 |
|----------------|------------------|--------------------------|
| AWS            | AWS Lambda       | API Gateway, S3, DynamoDB, SQS 등 |
| GCP            | Cloud Functions  | Pub/Sub, Firestore, GCS 등 |
| Azure          | Azure Functions  | Event Grid, Cosmos DB 등 |
| Netlify / Vercel | Edge Functions | Jamstack 기반 프론트엔드 함수 |
| Cloudflare     | Workers          | 초고속 글로벌 엣지 함수 실행 |

---

## 🎯 정리 요약

✔ 서버리스는 **인프라 없이 코드만으로 서비스 구축이 가능한 클라우드 아키텍처**  
✔ 빠른 개발, 비용 효율, 확장성이 장점  
✔ 콜드 스타트, 상태 관리, 디버깅은 설계 시 주의  
✔ 단일 서비스 → 서버리스로 전체 구성하거나, **일부 기능만 서버리스로 분리**하는 하이브리드 접근도 유효
